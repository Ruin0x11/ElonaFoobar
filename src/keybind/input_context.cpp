#include "input_context.hpp"
#include "../audio.hpp"
#include "../config/config.hpp"
#include "../variables.hpp"
#include "keybind_manager.hpp"

namespace elona
{

namespace
{

// The last held key has to be global across all input contexts, because a key
// can generate two different actions in different contexts. If key delay
// depended on the last action generated by a keypress, when the context is
// changed by entering a menu, there would be no key delay and the key would be
// counted as pressed twice.

struct LastHeldInfo
{
    void clear()
    {
        input.clear();
        frames = 0;
    }

    MatchedInput input{};
    int frames = 0;
};

LastHeldInfo last_held;

} // namespace

// This map holds the action categories available in an input context.
// Categories at the top will override categories further down. This is to
// support the behavior of toggling wizard mode.
// TODO: It still needs to support ignoring key conflicts for togglable
// categories.

// clang-format off
static std::map<InputContextType, std::vector<ActionCategory>> input_context_types =
{
    {InputContextType::menu, {ActionCategory::shortcut,
                              ActionCategory::menu,
                              ActionCategory::selection,
                              ActionCategory::default_}},

    {InputContextType::game, {ActionCategory::wizard,
                              ActionCategory::game,
                              ActionCategory::shortcut,
                              ActionCategory::default_}}
};
// clang-format on

optional<MatchedInput> InputContext::_matches(
    const std::string& action_id,
    snail::ModKey modifiers)
{
    if (_available_actions.find(action_id) == _available_actions.end())
    {
        return none;
    }

    const auto& binding = KeybindManager::instance().binding(action_id);

    const auto pressed = [](const Keybind& keybind, snail::ModKey modifiers) {
        return keybind.modifiers == modifiers
            && snail::Input::instance().is_pressed(keybind.main, modifiers);
    };

    if (pressed(binding.primary, modifiers))
    {
        return MatchedInput(action_id, binding.primary);
    }
    if (pressed(binding.alternate, modifiers))
    {
        return MatchedInput(action_id, binding.alternate);
    }
    if (pressed(binding.permanent, modifiers))
    {
        return MatchedInput(action_id, binding.permanent);
    }
    if (snail::Input::instance().is_pressed(binding.joystick_button))
    {
        return MatchedInput(action_id, binding.joystick_button);
    }

    return none;
}

optional<MatchedInput> InputContext::_check_normal_action(
    snail::ModKey modifiers)
{

    for (const auto& action_id : _available_actions_sorted)
    {
        bool excluded =
            _excluded_categories.find(keybind::actions.at(action_id).category)
            != _excluded_categories.end();

        if (!excluded)
        {
            if (auto matched = _matches(action_id, modifiers))
            {
                return matched;
            }
        }
    }

    return none;
}

optional<std::string> InputContext::_check_movement_action(
    const std::set<snail::Key>& keys,
    snail::ModKey modifiers)
{
    StickKey input = StickKey::none;

    // Movement keys have to ignore Shift or Alt. They could be used with them
    // in a hardcoded manner for running or diagonal restriction.
    // TODO: At least make this clear to players somehow.
    snail::ModKey key_modifiers =
        modifiers & ~(snail::ModKey::shift | snail::ModKey::alt);


    // NOTE: Escape acts as both "summon the quit menu" at the main game
    // loop and "cancel", but actual checks for escape being pressed are
    // relatively few. Setting the global key_escape = true is to avoid
    // having to do (action == "cancel" || action == "escape") everywhere.
    if (_matches("escape", key_modifiers))
    {
        bool just_pressed = keywait == 0;
        keywait = 1;
        key_escape = true;

        if (just_pressed)
        {
            return "cancel"s;
        }
        else
        {
            return ""s;
        }
    }

    if (_matches("north", key_modifiers))
    {
        input |= StickKey::up;
    }
    if (_matches("south", key_modifiers))
    {
        input |= StickKey::down;
    }
    if (_matches("east", key_modifiers))
    {
        input |= StickKey::left;
    }
    if (_matches("west", key_modifiers))
    {
        input |= StickKey::right;
    }
    if (_matches("northwest", key_modifiers))
    {
        input = StickKey::up | StickKey::left;
    }
    if (_matches("northeast", key_modifiers))
    {
        input = StickKey::up | StickKey::right;
    }
    if (_matches("southwest", key_modifiers))
    {
        input = StickKey::down | StickKey::left;
    }
    if (_matches("southeast", key_modifiers))
    {
        input = StickKey::down | StickKey::right;
    }

    // If there is still no movement direction, then some other key was pressed.
    // Otherwise there would have been no key check.
    if (input == StickKey::none)
    {
        for (const auto& key : keys)
        {
            if (!is_modifier(key))
            {
                // Encountered non-movement key, prioritize it over
                // movement.
                return none;
            }
        }
    }


    if ((modifiers & snail::ModKey::shift) == snail::ModKey::shift)
    {
        // Has to be modified globally, since scroll speed is determined by
        // keybd_wait. See @ref ui_scroll_screen()
        keybd_wait = 100000;
        if (keywait == 0)
        {
            keywait = 1;
            return "cancel"s;
        }
    }
    else
    {
        keywait = 0;
    }


    if ((modifiers & snail::ModKey::alt) != snail::ModKey::alt)
    {
        if (input == StickKey::left)
        {
            return "west"s;
        }
        if (input == StickKey::up)
        {
            return "north"s;
        }
        if (input == StickKey::right)
        {
            return "east"s;
        }
        if (input == StickKey::down)
        {
            return "south"s;
        }
    }
    if (input == (StickKey::up | StickKey::left))
    {
        return "northwest"s;
    }
    if (input == (StickKey::up | StickKey::right))
    {
        return "northeast"s;
    }
    if (input == (StickKey::down | StickKey::left))
    {
        return "southwest"s;
    }
    if (input == (StickKey::down | StickKey::right))
    {
        return "southeast"s;
    }

    return none;
}

bool InputContext::_is_nonmovement_key(const snail::Key& k)
{
    return keybind_is_bindable_key(k) || k == snail::Key::enter;
}

InputContext InputContext::create(InputContextType type)
{
    InputContext result;

    const auto& categories = input_context_types.at(type);
    for (const auto& category : categories)
    {
        result._add_actions_from_category(category);
    }

    return result;
}

void InputContext::_add_actions_from_category(ActionCategory category)
{
    for (const auto& pair : keybind::actions)
    {
        const auto& action_id = pair.first;
        const auto& action = pair.second;

        if (action.category == category)
        {
            _available_actions.insert(action_id);
            _available_actions_sorted.push_back(action_id);
        }
    }
}

std::string InputContext::_delay_movement_action(
    const std::string& action,
    snail::ModKey modifiers,
    KeyWaitDelay delay_type)
{
    if (keybd_wait >= 100000)
    {
        if ((modifiers & snail::ModKey::shift) != snail::ModKey::shift)
        {
            keybd_wait = 1000;
        }
    }

    if (delay_type == KeyWaitDelay::none)
    {
        return action;
    }

    if (delay_type == KeyWaitDelay::walk_run)
    {
        if (keybd_attacking != 0)
        {
            if (keybd_wait % Config::instance().attackwait != 0)
            {
                return ""s;
            }
        }
        else if (Config::instance().scroll == 0)
        {
            if (keybd_wait
                < Config::instance().walkwait * Config::instance().startrun)
            {
                if (keybd_wait % Config::instance().walkwait != 0)
                {
                    return ""s;
                }
            }
            else
            {
                running = 1;
                if (keybd_wait < 100000)
                {
                    if (keybd_wait % Config::instance().runwait != 0)
                    {
                        return ""s;
                    }
                }
            }
        }
        // else if (input == StickKey::none)
        else if (action == "wait"s)
        {
            if (keybd_wait < 20)
            {
                if (keybd_wait != 0)
                {
                    return ""s;
                }
            }
        }
        else if (keybd_wait > Config::instance().startrun)
        {
            if (Config::instance().runscroll == 0)
            {
                if (keybd_wait % Config::instance().runwait != 0)
                {
                    return ""s;
                }
            }
            running = 1;
        }
    }
    else if (
        keybd_wait
        < Config::instance().select_fast_start * Config::instance().select_wait)
    {
        if (keybd_wait % Config::instance().select_wait != 0)
        {
            return ""s;
        }
    }
    else if (keybd_wait < 1000)
    {
        if (keybd_wait % Config::instance().select_fast_wait != 0)
        {
            return ""s;
        }
    }

    return action;
}

static bool
_is_keypress_delayed(int held_frames, int keywait, int initial_keywait)
{
    if (held_frames < initial_keywait)
    {
        if (held_frames == 0)
        {
            return false;
        }
    }
    else if (held_frames % keywait == 0)
    {
        return false;
    }

    return true;
}

bool InputContext::_delay_normal_action(const MatchedInput& input)
{
    if (!last_held.input.matches(input))
    {
        last_held.frames = 0;
    }

    bool delayed = _is_keypress_delayed(last_held.frames, 1, 20);

    if (last_held.frames == 0)
    {
        last_held.input = input;
    }

    last_held.frames++;

    if (delayed)
    {
        return true;
    }

    return false;
} // namespace elona

std::string InputContext::check_for_command(KeyWaitDelay delay_type)
{
    key_escape = false;

    const auto& keys = snail::Input::instance().pressed_keys();
    auto modifiers = snail::Input::instance().modifiers();

    if (/* !shortcut && */ keyhalt != 0)
    {
        if (keys.size() > 0)
        {
            keybd_wait = 0;
            return "";
        }
        else
        {
            keyhalt = 0;
        }
    }

    if (const auto action = _check_movement_action(keys, modifiers))
    {
        last_held.clear();

        // Movement keys have special key delay behavior, so handle them.
        auto result = _delay_movement_action(*action, modifiers, delay_type);
        ++keybd_wait;

        return result;
    }
    else
    {
        keybd_wait = 0;
        keybd_attacking = 0;
        running = 0;
    }

    if (const auto matched = _check_normal_action(modifiers))
    {
        if (!_delay_normal_action(*matched))
        {
            return matched->action_id;
        }
    }
    else
    {
        last_held.clear();
    }

    return ""s;
}

std::string InputContext::check_for_command_with_list(int& list_index)
{
    auto action = check_for_command(KeyWaitDelay::always);

    if (action == "north"s)
    {
        snd("core.cursor1");
        --cs;
        if (cs < 0)
        {
            cs = keyrange - 1;
            if (cs < 0)
            {
                cs = 0;
            }
        }
    }
    if (action == "south"s)
    {
        snd("core.cursor1");
        ++cs;
        if (cs >= keyrange)
        {
            cs = 0;
        }
    }
    if (action == "west"s)
    {
        action = "previous_page"s;
    }
    if (action == "east"s)
    {
        action = "next_page"s;
    }
    if (cs >= keyrange)
    {
        cs_bk = -1;
        cs = keyrange - 1;
        if (cs < 0)
        {
            cs = 0;
        }
    }
    if (action == "enter"s)
    {
        list_index = cs;
    }
    else if (keybind_action_has_category(action, ActionCategory::selection))
    {
        list_index = keybind_index_number(action);
    }
    else
    {
        list_index = -1;
    }
    return action;
}

void InputContext::reset()
{
    snail::Input::instance().clear_pressed_keys_and_modifiers();
    key_escape = false;
    last_held.clear();
}

InputContext& InputContext::instance()
{
    static optional<InputContext> the_input_context;
    if (!the_input_context)
    {
        the_input_context = create(InputContextType::game);
    }
    return *the_input_context;
}

InputContext& InputContext::for_menu()
{
    static optional<InputContext> the_input_context;
    if (!the_input_context)
    {
        the_input_context = create(InputContextType::menu);
    }
    return *the_input_context;
}

std::unordered_set<ActionCategory> keybind_conflicting_action_categories(
    ActionCategory action_category)
{
    std::unordered_set<ActionCategory> result;
    for (const auto& pair : input_context_types)
    {
        const auto& categories = pair.second;
        bool is_in_context =
            std::find(categories.begin(), categories.end(), action_category)
            != categories.end();

        // If the action can be returned from input in this category, the
        // keybinding for it cannot confict with other actions in other
        // categories for the same input context type.
        if (is_in_context)
        {
            result.insert(categories.begin(), categories.end());
        }
    }
    return result;
}

} // namespace elona
